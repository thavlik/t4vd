// Code generated by oto; DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"

	"github.com/pkg/errors"

	"github.com/peterbourgon/unixtransport"
)

type basicAuth struct {
	username string
	password string
}

type CompilerClientOptions struct {
	basicAuth *basicAuth
	timeout   *time.Duration
	transport http.RoundTripper
}

func NewCompilerClientOptions() *CompilerClientOptions {
	return &CompilerClientOptions{}
}

func (o *CompilerClientOptions) SetBasicAuth(username, password string) *CompilerClientOptions {
	o.basicAuth = &basicAuth{
		username: username,
		password: password,
	}
	return o
}

func (o *CompilerClientOptions) SetTimeout(timeout time.Duration) *CompilerClientOptions {
	o.timeout = &timeout
	return o
}

func (o *CompilerClientOptions) SetTransport(transport http.RoundTripper) *CompilerClientOptions {
	o.transport = transport
	return o
}

func (o *CompilerClientOptions) apply(c *compilerClient) {
	c.basicAuth = o.basicAuth
	if o.timeout != nil {
		c.cl.Timeout = *o.timeout
	}
	if o.transport != nil {
		c.cl.Transport = o.transport
	}
}

type compilerClient struct {
	endpoint  string
	basicAuth *basicAuth
	cl        *http.Client
}

func NewCompilerClient(
	endpoint string,
	options ...*CompilerClientOptions,
) Compiler {
	var transport http.RoundTripper
	if strings.HasPrefix(endpoint, "http+unix://") || strings.HasPrefix(endpoint, "https+unix://") {
		if !strings.HasSuffix(endpoint, ":") {
			endpoint += ":"
		}
		t := &http.Transport{}
		unixtransport.Register(t)
		transport = t
	}
	c := &compilerClient{
		endpoint: endpoint,
		cl:       &http.Client{Transport: transport},
	}
	for _, option := range options {
		option.apply(c)
	}
	return c
}

func (c *compilerClient) Compile(ctx context.Context, req Compile) (*Void, error) {
	var body bytes.Buffer
	if err := json.NewEncoder(&body).Encode(&req); err != nil {
		return nil, errors.Wrap(err, "encode")
	}
	request, err := http.NewRequestWithContext(
		ctx,
		"POST",
		fmt.Sprintf("%s/oto/Compiler.Compile", c.endpoint),
		&body,
	)
	if err != nil {
		return nil, errors.Wrap(err, "build request")
	}
	if c.basicAuth != nil {
		request.SetBasicAuth(c.basicAuth.username, c.basicAuth.password)
	}
	request.Header.Set("Content-Type", "application/json")
	resp, err := c.cl.Do(request)
	if err != nil {
		return nil, errors.Wrap(err, "http")
	}
	defer resp.Body.Close()
	if resp.StatusCode != 200 {
		body, _ := io.ReadAll(resp.Body)
		if resp.StatusCode == 500 {
			return nil, errors.New(string(body))
		}
		return nil, fmt.Errorf("status code %d: %s", resp.StatusCode, string(body))
	}
	var response Void
	if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
		return nil, errors.Wrap(err, "decode")
	}
	return &response, nil
}

func (c *compilerClient) GetDataset(ctx context.Context, req GetDatasetRequest) (*Dataset, error) {
	var body bytes.Buffer
	if err := json.NewEncoder(&body).Encode(&req); err != nil {
		return nil, errors.Wrap(err, "encode")
	}
	request, err := http.NewRequestWithContext(
		ctx,
		"POST",
		fmt.Sprintf("%s/oto/Compiler.GetDataset", c.endpoint),
		&body,
	)
	if err != nil {
		return nil, errors.Wrap(err, "build request")
	}
	if c.basicAuth != nil {
		request.SetBasicAuth(c.basicAuth.username, c.basicAuth.password)
	}
	request.Header.Set("Content-Type", "application/json")
	resp, err := c.cl.Do(request)
	if err != nil {
		return nil, errors.Wrap(err, "http")
	}
	defer resp.Body.Close()
	if resp.StatusCode != 200 {
		body, _ := io.ReadAll(resp.Body)
		if resp.StatusCode == 500 {
			return nil, errors.New(string(body))
		}
		return nil, fmt.Errorf("status code %d: %s", resp.StatusCode, string(body))
	}
	var response Dataset
	if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
		return nil, errors.Wrap(err, "decode")
	}
	return &response, nil
}
