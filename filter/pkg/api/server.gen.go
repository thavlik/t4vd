// Code generated by oto; DO NOT EDIT.

package api

import (
	"context"
	"log"
	"net/http"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"

	"github.com/pacedotdev/oto/otohttp"

	time "time"
)

var (
	filterClassifyTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "filter_classify_total",
		Help: "Auto-generated metric incremented on every call to Filter.Classify",
	})
	filterClassifySuccessTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "filter_classify_success_total",
		Help: "Auto-generated metric incremented on every call to Filter.Classify that does not return with an error",
	})

	filterSampleTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "filter_sample_total",
		Help: "Auto-generated metric incremented on every call to Filter.Sample",
	})
	filterSampleSuccessTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "filter_sample_success_total",
		Help: "Auto-generated metric incremented on every call to Filter.Sample that does not return with an error",
	})
)

type Filter interface {
	Classify(context.Context, Label) (*Label, error)
	Sample(context.Context, SampleRequest) (*SampleResponse, error)
}

type filterServer struct {
	server *otohttp.Server
	filter Filter
}

func RegisterFilter(server *otohttp.Server, filter Filter) {
	handler := &filterServer{
		server: server,
		filter: filter,
	}
	server.Register("Filter", "Classify", handler.handleClassify)
	server.Register("Filter", "Sample", handler.handleSample)
}

func (s *filterServer) handleClassify(w http.ResponseWriter, r *http.Request) {
	filterClassifyTotal.Inc()
	var request Label
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.filter.Classify(r.Context(), request)
	if err != nil {
		log.Println("TODO: oto service error:", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	filterClassifySuccessTotal.Inc()
}

func (s *filterServer) handleSample(w http.ResponseWriter, r *http.Request) {
	filterSampleTotal.Inc()
	var request SampleRequest
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.filter.Sample(r.Context(), request)
	if err != nil {
		log.Println("TODO: oto service error:", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	filterSampleSuccessTotal.Inc()
}

type Label struct {
	ID        string                 `json:"id"`
	GadgetID  string                 `json:"gadgetID"`
	ProjectID string                 `json:"projectID"`
	Comment   string                 `json:"comment"`
	Deleted   *time.Time             `json:"deleted"`
	DeleterID string                 `json:"deleterID"`
	CreatorID string                 `json:"creatorID"`
	Created   *time.Time             `json:"created"`
	Parent    *Label                 `json:"parent"`
	Payload   map[string]interface{} `json:"payload"`
	Tags      []string               `json:"tags"`
	Seek      time.Duration          `json:"seek"`
	Pad       time.Duration          `json:"pad"`
	Error     string                 `json:"error,omitempty"`
}

type SampleRequest struct {
	ProjectID string `json:"projectID"`
	BatchSize int    `json:"batchSize"`
}

type SampleResponse struct {
	Labels []*Label `json:"labels"`
	Error  string   `json:"error,omitempty"`
}
